---
title: 'MCP Roots å®Œå…¨æŒ‡å—'
date: '2025-11-13'
excerpt: 'Model Context Protocol (MCP) Roots - æ–‡ä»¶ç³»ç»Ÿè¾¹ç•Œç®¡ç†æ·±åº¦è§£æ'
tags: ['AI', 'MCP']
series: 'AIå­¦ä¹ '
---

# MCP Roots å®Œå…¨æŒ‡å—

> Model Context Protocol (MCP) Roots - æ–‡ä»¶ç³»ç»Ÿè¾¹ç•Œç®¡ç†æ·±åº¦è§£æ

## ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
- [åè®®è§„èŒƒ](#åè®®è§„èŒƒ)
- [å·¥ä½œæµç¨‹](#å·¥ä½œæµç¨‹)
- [å®ç°ç¤ºä¾‹](#å®ç°ç¤ºä¾‹)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å®‰å…¨æŒ‡å—](#å®‰å…¨æŒ‡å—)

---

## æ¦‚è¿°

### ä»€ä¹ˆæ˜¯ MCP Rootsï¼Ÿ

**Roots** æ˜¯ MCP å®¢æˆ·ç«¯å‘æœåŠ¡å™¨æš´éœ²çš„æ–‡ä»¶ç³»ç»Ÿè¾¹ç•Œï¼Œå®šä¹‰äº†æœåŠ¡å™¨å¯ä»¥è®¿é—®çš„ç›®å½•å’Œæ–‡ä»¶èŒƒå›´ã€‚è¿™æ˜¯ä¸€ä¸ª**å®¢æˆ·ç«¯æä¾›çš„èƒ½åŠ›**ï¼Œç”¨äºä¿æŠ¤ç”¨æˆ·çš„æ–‡ä»¶ç³»ç»Ÿå®‰å…¨ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦ Rootsï¼Ÿ

```
æ²¡æœ‰ Roots çš„é£é™©:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Server å¯ä»¥è®¿é—®æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿ:                  â”‚
â”‚  /                                           â”‚
â”‚  â”œâ”€â”€ home/                                   â”‚
â”‚  â”‚   â”œâ”€â”€ user/                               â”‚
â”‚  â”‚   â”‚   â”œâ”€â”€ documents/         â† é¡¹ç›®æ–‡ä»¶   â”‚
â”‚  â”‚   â”‚   â”œâ”€â”€ .ssh/              â† å±é™©ï¼     â”‚
â”‚  â”‚   â”‚   â”œâ”€â”€ secrets.txt        â† å±é™©ï¼     â”‚
â”‚  â”‚   â”‚   â””â”€â”€ passwords.db       â† å±é™©ï¼     â”‚
â”‚  â”‚   â””â”€â”€ other-user/            â† å±é™©ï¼     â”‚
â”‚  â”œâ”€â”€ etc/                       â† å±é™©ï¼     â”‚
â”‚  â””â”€â”€ system/                    â† å±é™©ï¼     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä½¿ç”¨ Roots çš„å®‰å…¨æ–¹æ¡ˆ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Client å®šä¹‰å…è®¸çš„ Roots:                      â”‚
â”‚                                              â”‚
â”‚  Root 1: file:///home/user/project-a         â”‚
â”‚  Root 2: file:///home/user/project-b         â”‚
â”‚                                              â”‚
â”‚  Server åªèƒ½è®¿é—®:                             â”‚
â”‚  âœ… /home/user/project-a/                    â”‚
â”‚  âœ… /home/user/project-b/                    â”‚
â”‚  âŒ /home/user/.ssh/                         â”‚
â”‚  âŒ /home/user/secrets.txt                   â”‚
â”‚  âŒ /etc/passwd                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒä»·å€¼

- ğŸ›¡ï¸ **å®‰å…¨éš”ç¦»**: é™åˆ¶æœåŠ¡å™¨åªèƒ½è®¿é—®å…è®¸çš„ç›®å½•
- ğŸ¯ **ç²¾ç¡®æ§åˆ¶**: ç”¨æˆ·æ˜ç¡®æˆæƒå“ªäº›è·¯å¾„å¯è¢«è®¿é—®
- ğŸ”„ **åŠ¨æ€ç®¡ç†**: æ”¯æŒè¿è¡Œæ—¶æ·»åŠ /ç§»é™¤ Roots
- ğŸ“¢ **å˜åŒ–é€šçŸ¥**: å½“ Roots å˜åŒ–æ—¶é€šçŸ¥æœåŠ¡å™¨

---

## æ ¸å¿ƒæ¦‚å¿µ

### MCP æ¶æ„ä¸­çš„ Roots

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MCP Client                           â”‚
â”‚  (Claude Desktop, VS Code, IDE)                        â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚           Roots Manager                          â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚  Allowed Roots:                            â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ file:///home/user/project-a             â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ file:///home/user/project-b             â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ file:///workspace/shared                â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â”‚                                                  â”‚  â”‚
â”‚  â”‚  åŠŸèƒ½:                                            â”‚  â”‚
â”‚  â”‚  â€¢ ç®¡ç† Root åˆ—è¡¨                                â”‚  â”‚
â”‚  â”‚  â€¢ å“åº” roots/list è¯·æ±‚                         â”‚  â”‚
â”‚  â”‚  â€¢ ç›‘æ§è·¯å¾„å˜åŒ–                                  â”‚  â”‚
â”‚  â”‚  â€¢ å‘é€å˜åŒ–é€šçŸ¥                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â”‚         â†• JSON-RPC 2.0 (stdio/HTTP+SSE)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MCP Server                           â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚           File Operations                        â”‚  â”‚
â”‚  â”‚                                                  â”‚  â”‚
â”‚  â”‚  1. è¯·æ±‚ Roots åˆ—è¡¨                              â”‚  â”‚
â”‚  â”‚     roots/list â†’                                â”‚  â”‚
â”‚  â”‚     â† [root1, root2, ...]                       â”‚  â”‚
â”‚  â”‚                                                  â”‚  â”‚
â”‚  â”‚  2. éªŒè¯æ–‡ä»¶è·¯å¾„                                 â”‚  â”‚
â”‚  â”‚     âœ… /home/user/project-a/src/main.ts         â”‚  â”‚
â”‚  â”‚     âŒ /etc/passwd (è¶…å‡ºèŒƒå›´)                    â”‚  â”‚
â”‚  â”‚                                                  â”‚  â”‚
â”‚  â”‚  3. å®‰å…¨åœ°æ‰§è¡Œæ–‡ä»¶æ“ä½œ                           â”‚  â”‚
â”‚  â”‚     è¯»å–ã€å†™å…¥ã€åˆ—å‡ºç›®å½•ç­‰                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Root çš„æ•°æ®ç»“æ„

```typescript
interface Root {
  uri: string;    // å¿…éœ€ï¼šfile:// URI
  name?: string;  // å¯é€‰ï¼šäººç±»å¯è¯»çš„åç§°
}

// ç¤ºä¾‹
{
  uri: "file:///home/user/projects/my-app",
  name: "My Application"
}
```

---

## åè®®è§„èŒƒ

### 1. èƒ½åŠ›å£°æ˜

å®¢æˆ·ç«¯å¿…é¡»åœ¨åˆå§‹åŒ–æ—¶å£°æ˜ `roots` èƒ½åŠ›ï¼š

```typescript
// Client åˆå§‹åŒ–
{
  "capabilities": {
    "roots": {
      "listChanged": true  // æ˜¯å¦æ”¯æŒå˜åŒ–é€šçŸ¥
    }
  }
}
```

**å‚æ•°è¯´æ˜ï¼š**

- `listChanged`: å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºå®¢æˆ·ç«¯æ˜¯å¦ä¼šåœ¨ Roots åˆ—è¡¨å˜åŒ–æ—¶å‘é€é€šçŸ¥

### 2. åˆ—å‡º Roots (roots/list)

æœåŠ¡å™¨é€šè¿‡å‘é€ `roots/list` è¯·æ±‚è·å–å…è®¸çš„ Rootsï¼š

**è¯·æ±‚æ ¼å¼ï¼š**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

**å“åº”æ ¼å¼ï¼š**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/my-app",
        "name": "My Application"
      },
      {
        "uri": "file:///home/user/projects/shared-lib",
        "name": "Shared Library"
      },
      {
        "uri": "file:///workspace/docs",
        "name": "Documentation"
      }
    ]
  }
}
```

### 3. Roots å˜åŒ–é€šçŸ¥ (notifications/roots/list_changed)

å½“ Roots åˆ—è¡¨å‘ç”Ÿå˜åŒ–æ—¶ï¼Œå®¢æˆ·ç«¯å‘é€é€šçŸ¥ï¼š

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

**æ³¨æ„ï¼š**

- é€šçŸ¥ä¸åŒ…å«æ–°çš„ Roots åˆ—è¡¨
- æœåŠ¡å™¨æ”¶åˆ°é€šçŸ¥ååº”é‡æ–°è¯·æ±‚ `roots/list`
- åªæœ‰å£°æ˜äº† `listChanged: true` çš„å®¢æˆ·ç«¯æ‰ä¼šå‘é€æ­¤é€šçŸ¥

---

## å·¥ä½œæµç¨‹

### å®Œæ•´çš„ Roots å·¥ä½œæµ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 1: åˆå§‹åŒ–å’Œèƒ½åŠ›åå•†                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Client â†’ Server: initialize request
{
  clientInfo: { name: "Claude Desktop" },
  capabilities: {
    roots: { listChanged: true }  â† å£°æ˜æ”¯æŒ Roots
  }
}

Server â†’ Client: initialize response
{
  serverInfo: { name: "My MCP Server" },
  capabilities: {
    tools: {},
    resources: {}
  }
}

âœ… åŒæ–¹çŸ¥é“å½¼æ­¤çš„èƒ½åŠ›

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 2: æœåŠ¡å™¨è¯·æ±‚ Roots                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Server â†’ Client: roots/list request
{
  jsonrpc: "2.0",
  id: 1,
  method: "roots/list"
}

Client å†…éƒ¨å¤„ç†:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. æ”¶é›†å½“å‰æ‰“å¼€çš„é¡¹ç›®             â”‚
â”‚ 2. æ£€æŸ¥ç”¨æˆ·æƒé™è®¾ç½®               â”‚
â”‚ 3. æ„å»º Roots åˆ—è¡¨                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Client â†’ Server: roots/list response
{
  jsonrpc: "2.0",
  id: 1,
  result: {
    roots: [
      { uri: "file:///home/user/project-a", name: "Project A" },
      { uri: "file:///home/user/project-b", name: "Project B" }
    ]
  }
}

Server ç¼“å­˜ Roots ä¿¡æ¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ cachedRoots = [                   â”‚
â”‚   "file:///home/user/project-a", â”‚
â”‚   "file:///home/user/project-b"  â”‚
â”‚ ]                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 3: æœåŠ¡å™¨ä½¿ç”¨ Roots éªŒè¯è·¯å¾„                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Server éœ€è¦è¯»å–æ–‡ä»¶: /home/user/project-a/src/main.ts

éªŒè¯æµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. è§„èŒƒåŒ–è·¯å¾„                                     â”‚
â”‚    /home/user/project-a/src/main.ts             â”‚
â”‚    â†“                                             â”‚
â”‚    file:///home/user/project-a/src/main.ts      â”‚
â”‚                                                  â”‚
â”‚ 2. æ£€æŸ¥æ˜¯å¦åŒ¹é…ä»»ä½• Root                          â”‚
â”‚    file:///home/user/project-a/src/main.ts      â”‚
â”‚    startsWith(file:///home/user/project-a) ?    â”‚
â”‚    âœ… YES                                        â”‚
â”‚                                                  â”‚
â”‚ 3. å…è®¸è®¿é—®                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Server æ‰§è¡Œæ–‡ä»¶æ“ä½œ:
const content = await fs.readFile(
  "/home/user/project-a/src/main.ts"
);

å¦ä¸€ä¸ªç¤ºä¾‹ - æ‹’ç»è®¿é—®:
Server å°è¯•è®¿é—®: /etc/passwd

éªŒè¯æµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. è§„èŒƒåŒ–è·¯å¾„                                     â”‚
â”‚    file:///etc/passwd                            â”‚
â”‚                                                  â”‚
â”‚ 2. æ£€æŸ¥æ˜¯å¦åŒ¹é…ä»»ä½• Root                          â”‚
â”‚    file:///etc/passwd                            â”‚
â”‚    startsWith(file:///home/user/project-a) ?    â”‚
â”‚    âŒ NO                                         â”‚
â”‚    startsWith(file:///home/user/project-b) ?    â”‚
â”‚    âŒ NO                                         â”‚
â”‚                                                  â”‚
â”‚ 3. æ‹’ç»è®¿é—®                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Error: Access denied - path outside allowed roots

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 4: åŠ¨æ€æ›´æ–° Roots                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User æ“ä½œ: æ‰“å¼€æ–°é¡¹ç›® "project-c"

Client å†…éƒ¨æ›´æ–°:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ roots.push({                     â”‚
â”‚   uri: "file:///home/user/       â”‚
â”‚         project-c",              â”‚
â”‚   name: "Project C"              â”‚
â”‚ })                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Client â†’ Server: å‘é€å˜åŒ–é€šçŸ¥
{
  jsonrpc: "2.0",
  method: "notifications/roots/list_changed"
}

Server æ”¶åˆ°é€šçŸ¥:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. æ¸…é™¤ç¼“å­˜çš„ Roots               â”‚
â”‚ 2. é‡æ–°è¯·æ±‚ roots/list            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Server â†’ Client: roots/list
Client â†’ Server: è¿”å›æ›´æ–°åçš„åˆ—è¡¨ (åŒ…å« project-c)

Server æ›´æ–°ç¼“å­˜:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ cachedRoots = [                   â”‚
â”‚   "file:///home/user/project-a", â”‚
â”‚   "file:///home/user/project-b", â”‚
â”‚   "file:///home/user/project-c"  â”‚ â† æ–°å¢
â”‚ ]                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ… Server ç°åœ¨å¯ä»¥è®¿é—® project-c
```

### å…¸å‹ä½¿ç”¨åœºæ™¯

#### åœºæ™¯ 1: IDE/ç¼–è¾‘å™¨é›†æˆ

```
ç”¨æˆ·æ‰“å¼€ VS Codeï¼Œæœ‰ 3 ä¸ªå·¥ä½œåŒºæ–‡ä»¶å¤¹:

VS Code å·¥ä½œåŒº:
â”œâ”€â”€ /home/user/frontend (React é¡¹ç›®)
â”œâ”€â”€ /home/user/backend (Node.js API)
â””â”€â”€ /home/user/shared (å…±äº«åº“)

MCP Client (VS Code æ‰©å±•) æš´éœ²è¿™äº›ä¸º Roots:

roots: [
  {
    uri: "file:///home/user/frontend",
    name: "Frontend (React)"
  },
  {
    uri: "file:///home/user/backend",
    name: "Backend (Node.js)"
  },
  {
    uri: "file:///home/user/shared",
    name: "Shared Libraries"
  }
]

MCP Server å¯ä»¥:
âœ… è¯»å– /home/user/frontend/src/App.tsx
âœ… ä¿®æ”¹ /home/user/backend/api/routes.js
âœ… åˆ—å‡º /home/user/shared/utils/
âŒ è®¿é—® /home/user/documents/
âŒ è®¿é—® /home/user/.ssh/
```

#### åœºæ™¯ 2: ç‰ˆæœ¬æ§åˆ¶é›†æˆ

```
ç”¨æˆ·å…‹éš†äº†å¤šä¸ª Git ä»“åº“:

Git ä»“åº“:
â”œâ”€â”€ /repositories/project-main
â”œâ”€â”€ /repositories/project-docs
â””â”€â”€ /repositories/project-tools

MCP Server å®ç° Git æ“ä½œå·¥å…·ï¼Œéœ€è¦è®¿é—®è¿™äº›ä»“åº“:

Client æš´éœ² Roots:
roots: [
  {
    uri: "file:///repositories/project-main",
    name: "Main Repository"
  },
  {
    uri: "file:///repositories/project-docs",
    name: "Documentation"
  },
  {
    uri: "file:///repositories/project-tools",
    name: "Build Tools"
  }
]

Server Tool: git_status
âœ… å¯ä»¥è¯»å– .git/ ç›®å½•
âœ… å¯ä»¥æ‰§è¡Œ git å‘½ä»¤
âŒ ä¸èƒ½è®¿é—®å…¶ä»–ç›®å½•
```

#### åœºæ™¯ 3: ä¸´æ—¶é¡¹ç›®è®¿é—®

```
ç”¨æˆ·æƒ³ä¸´æ—¶æˆæƒ Server è®¿é—®ä¸€ä¸ªç›®å½•:

åˆå§‹çŠ¶æ€:
roots: [
  { uri: "file:///home/user/work/project-a" }
]

ç”¨æˆ·æ“ä½œ: "è®© AI è®¿é—®æˆ‘çš„ä¸´æ—¶è„šæœ¬ç›®å½•"

Client åŠ¨æ€æ·»åŠ  Root:
roots.push({
  uri: "file:///home/user/temp-scripts",
  name: "Temporary Scripts"
})

å‘é€é€šçŸ¥ â†’ Server é‡æ–°è·å– Roots

ç°åœ¨ Server å¯ä»¥:
âœ… è®¿é—® /home/user/temp-scripts/
âœ… ä»ç„¶å¯ä»¥è®¿é—® project-a

ç¨åç”¨æˆ·ç§»é™¤ä¸´æ—¶è®¿é—®:
roots = roots.filter(r => r.uri !== "file:///home/user/temp-scripts")

å‘é€é€šçŸ¥ â†’ Server æ›´æ–°

ç°åœ¨ Server:
âŒ ä¸èƒ½å†è®¿é—® temp-scripts/
âœ… ä»ç„¶å¯ä»¥è®¿é—® project-a
```

---

## å®ç°ç¤ºä¾‹

### TypeScript Client å®ç°

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { RootsListRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import * as path from 'path';
import * as fs from 'fs/promises';

interface Root {
  uri: string;
  name?: string;
}

class RootsManager {
  private client: Client;
  private allowedRoots: Root[];
  private watchers: Map<string, fs.FSWatcher> = new Map();

  constructor(client: Client) {
    this.client = client;
    this.allowedRoots = [];
    this.setupHandlers();
  }

  private setupHandlers() {
    // å¤„ç† roots/list è¯·æ±‚
    this.client.setRequestHandler(RootsListRequestSchema, async () => {
      console.log('[Roots] Server requested roots list');
      return {
        roots: this.allowedRoots,
      };
    });
  }

  // ========== Root ç®¡ç† ==========

  async addRoot(dirPath: string, name?: string): Promise<void> {
    // 1. éªŒè¯è·¯å¾„å­˜åœ¨
    try {
      const stats = await fs.stat(dirPath);
      if (!stats.isDirectory()) {
        throw new Error(`${dirPath} is not a directory`);
      }
    } catch (error) {
      throw new Error(`Invalid path: ${dirPath}`);
    }

    // 2. è§„èŒƒåŒ–è·¯å¾„
    const normalized = path.resolve(dirPath);
    const uri = `file://${normalized}`;

    // 3. æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    if (this.allowedRoots.some((r) => r.uri === uri)) {
      console.log(`[Roots] Root already exists: ${uri}`);
      return;
    }

    // 4. æ·»åŠ  Root
    this.allowedRoots.push({
      uri,
      name: name || path.basename(normalized),
    });

    console.log(`[Roots] Added root: ${uri}`);

    // 5. ç›‘æ§ç›®å½•å˜åŒ–ï¼ˆå¯é€‰ï¼‰
    this.watchRoot(normalized);

    // 6. é€šçŸ¥ Server
    await this.notifyRootsChanged();
  }

  async removeRoot(uri: string): Promise<void> {
    const index = this.allowedRoots.findIndex((r) => r.uri === uri);

    if (index === -1) {
      console.log(`[Roots] Root not found: ${uri}`);
      return;
    }

    // ç§»é™¤ Root
    this.allowedRoots.splice(index, 1);

    console.log(`[Roots] Removed root: ${uri}`);

    // åœæ­¢ç›‘æ§
    const dirPath = uri.replace('file://', '');
    this.unwatchRoot(dirPath);

    // é€šçŸ¥ Server
    await this.notifyRootsChanged();
  }

  getRoots(): Root[] {
    return [...this.allowedRoots];
  }

  hasRoot(uri: string): boolean {
    return this.allowedRoots.some((r) => r.uri === uri);
  }

  // ========== è·¯å¾„éªŒè¯ ==========

  isPathAllowed(filePath: string): boolean {
    const normalized = path.resolve(filePath);
    const fileUri = `file://${normalized}`;

    return this.allowedRoots.some((root) => fileUri.startsWith(root.uri));
  }

  validatePath(filePath: string): { valid: boolean; error?: string } {
    // 1. è§„èŒƒåŒ–è·¯å¾„
    const normalized = path.resolve(filePath);
    const fileUri = `file://${normalized}`;

    // 2. æ£€æŸ¥å±é™©æ¨¡å¼
    const dangerous = ['../..', '~', '/etc/', '/sys/', '/proc/'];
    for (const pattern of dangerous) {
      if (normalized.includes(pattern)) {
        return {
          valid: false,
          error: `Path contains dangerous pattern: ${pattern}`,
        };
      }
    }

    // 3. æ£€æŸ¥æ˜¯å¦åœ¨å…è®¸çš„ Roots å†…
    const matchedRoot = this.allowedRoots.find((root) => fileUri.startsWith(root.uri));

    if (!matchedRoot) {
      return {
        valid: false,
        error: `Path outside allowed roots.\nAllowed:\n${this.allowedRoots
          .map((r) => `  - ${r.name}: ${r.uri}`)
          .join('\n')}`,
      };
    }

    return { valid: true };
  }

  // ========== ç›®å½•ç›‘æ§ ==========

  private watchRoot(dirPath: string): void {
    if (this.watchers.has(dirPath)) {
      return; // å·²ç»åœ¨ç›‘æ§
    }

    try {
      const watcher = fs.watch(dirPath, { recursive: false }, (eventType, filename) => {
        console.log(`[Roots] Directory change detected: ${eventType} - ${filename}`);
        // å¯ä»¥åœ¨è¿™é‡Œå®ç°æ›´ç²¾ç»†çš„é€»è¾‘
      });

      this.watchers.set(dirPath, watcher as any);
      console.log(`[Roots] Watching directory: ${dirPath}`);
    } catch (error) {
      console.error(`[Roots] Failed to watch directory: ${error}`);
    }
  }

  private unwatchRoot(dirPath: string): void {
    const watcher = this.watchers.get(dirPath);
    if (watcher) {
      watcher.close();
      this.watchers.delete(dirPath);
      console.log(`[Roots] Stopped watching: ${dirPath}`);
    }
  }

  // ========== é€šçŸ¥ ==========

  private async notifyRootsChanged(): Promise<void> {
    try {
      await this.client.notification({
        method: 'notifications/roots/list_changed',
      });
      console.log('[Roots] Sent list_changed notification');
    } catch (error) {
      console.error('[Roots] Failed to send notification:', error);
    }
  }

  // ========== æ¸…ç† ==========

  cleanup(): void {
    // åœæ­¢æ‰€æœ‰ç›‘æ§
    for (const [dirPath, watcher] of this.watchers.entries()) {
      watcher.close();
      console.log(`[Roots] Stopped watching: ${dirPath}`);
    }
    this.watchers.clear();
  }
}

// ========== ä½¿ç”¨ç¤ºä¾‹ ==========

async function exampleUsage() {
  const client = new Client(
    {
      name: 'my-client',
      version: '1.0.0',
    },
    {
      capabilities: {
        roots: {
          listChanged: true,
        },
      },
    },
  );

  const rootsManager = new RootsManager(client);

  // æ·»åŠ  Roots
  await rootsManager.addRoot('/home/user/projects/app-a', 'Application A');
  await rootsManager.addRoot('/home/user/projects/app-b', 'Application B');

  // éªŒè¯è·¯å¾„
  const validation1 = rootsManager.validatePath('/home/user/projects/app-a/src/main.ts');
  console.log('Validation 1:', validation1); // { valid: true }

  const validation2 = rootsManager.validatePath('/etc/passwd');
  console.log('Validation 2:', validation2); // { valid: false, error: "..." }

  // ç§»é™¤ Root
  await rootsManager.removeRoot('file:///home/user/projects/app-b');

  // æ¸…ç†
  rootsManager.cleanup();
}
```

### TypeScript Server å®ç°

```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import * as fs from 'fs/promises';
import * as path from 'path';

interface Root {
  uri: string;
  name?: string;
}

class RootsAwareServer {
  private server: Server;
  private cachedRoots: Root[] = [];
  private lastRootsUpdate: number = 0;
  private readonly CACHE_TTL = 30000; // 30 seconds

  constructor() {
    this.server = new Server(
      {
        name: 'roots-aware-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      },
    );

    this.setupHandlers();
  }

  private setupHandlers() {
    // ç›‘å¬ Roots å˜åŒ–é€šçŸ¥
    this.server.setNotificationHandler('notifications/roots/list_changed', async () => {
      console.log('[Server] Roots changed notification received');
      this.cachedRoots = [];
      this.lastRootsUpdate = 0;
      await this.refreshRoots();
    });

    // å®šä¹‰ Tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: 'read_file',
            description: 'Read a file (within allowed roots)',
            inputSchema: {
              type: 'object',
              properties: {
                path: {
                  type: 'string',
                  description: 'Path to the file',
                },
              },
              required: ['path'],
            },
          },
          {
            name: 'write_file',
            description: 'Write to a file (within allowed roots)',
            inputSchema: {
              type: 'object',
              properties: {
                path: {
                  type: 'string',
                  description: 'Path to the file',
                },
                content: {
                  type: 'string',
                  description: 'Content to write',
                },
              },
              required: ['path', 'content'],
            },
          },
          {
            name: 'list_directory',
            description: 'List directory contents (within allowed roots)',
            inputSchema: {
              type: 'object',
              properties: {
                path: {
                  type: 'string',
                  description: 'Path to the directory',
                },
              },
              required: ['path'],
            },
          },
        ],
      };
    });

    // å¤„ç† Tool è°ƒç”¨
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      switch (name) {
        case 'read_file':
          return await this.handleReadFile(args.path as string);

        case 'write_file':
          return await this.handleWriteFile(args.path as string, args.content as string);

        case 'list_directory':
          return await this.handleListDirectory(args.path as string);

        default:
          throw new Error(`Unknown tool: ${name}`);
      }
    });
  }

  // ========== Roots ç®¡ç† ==========

  private async getRoots(forceRefresh = false): Promise<Root[]> {
    const now = Date.now();

    // ä½¿ç”¨ç¼“å­˜
    if (
      !forceRefresh &&
      this.cachedRoots.length > 0 &&
      now - this.lastRootsUpdate < this.CACHE_TTL
    ) {
      return this.cachedRoots;
    }

    return await this.refreshRoots();
  }

  private async refreshRoots(): Promise<Root[]> {
    try {
      console.log('[Server] Fetching roots from client...');

      const response = await this.server.request({ method: 'roots/list' }, { timeout: 5000 });

      this.cachedRoots = (response as any).roots || [];
      this.lastRootsUpdate = Date.now();

      console.log(`[Server] Got ${this.cachedRoots.length} roots`);

      return this.cachedRoots;
    } catch (error) {
      console.error('[Server] Failed to fetch roots:', error);
      return [];
    }
  }

  private async validatePath(filePath: string): Promise<{
    valid: boolean;
    error?: string;
    roots?: Root[];
  }> {
    // 1. è·å– Roots
    const roots = await this.getRoots();

    if (roots.length === 0) {
      return {
        valid: false,
        error: 'No roots available. Client may not support roots capability.',
      };
    }

    // 2. è§„èŒƒåŒ–è·¯å¾„
    const normalized = path.resolve(filePath);
    const fileUri = `file://${normalized}`;

    // 3. æ£€æŸ¥å±é™©æ¨¡å¼
    const dangerous = ['..', '~', '/etc/', '/sys/', '/proc/'];
    for (const pattern of dangerous) {
      if (normalized.includes(pattern)) {
        return {
          valid: false,
          error: `Path contains dangerous pattern: ${pattern}`,
        };
      }
    }

    // 4. æ£€æŸ¥æ˜¯å¦åœ¨å…è®¸çš„ Roots å†…
    const matchedRoot = roots.find((root) => fileUri.startsWith(root.uri));

    if (!matchedRoot) {
      return {
        valid: false,
        error: `Access denied: Path outside allowed roots.\n\nRequested: ${normalized}\n\nAllowed roots:\n${roots
          .map((r) => `  - ${r.name || 'Unnamed'}: ${r.uri}`)
          .join('\n')}`,
        roots,
      };
    }

    return { valid: true, roots };
  }

  // ========== Tool å®ç° ==========

  private async handleReadFile(filePath: string) {
    console.log(`[Server] read_file: ${filePath}`);

    // 1. éªŒè¯è·¯å¾„
    const validation = await this.validatePath(filePath);
    if (!validation.valid) {
      return {
        content: [
          {
            type: 'text',
            text: `âŒ Error: ${validation.error}`,
          },
        ],
        isError: true,
      };
    }

    // 2. è¯»å–æ–‡ä»¶
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      return {
        content: [
          {
            type: 'text',
            text: content,
          },
        ],
      };
    } catch (error: any) {
      return {
        content: [
          {
            type: 'text',
            text: `âŒ Error reading file: ${error.message}`,
          },
        ],
        isError: true,
      };
    }
  }

  private async handleWriteFile(filePath: string, content: string) {
    console.log(`[Server] write_file: ${filePath}`);

    // 1. éªŒè¯è·¯å¾„
    const validation = await this.validatePath(filePath);
    if (!validation.valid) {
      return {
        content: [
          {
            type: 'text',
            text: `âŒ Error: ${validation.error}`,
          },
        ],
        isError: true,
      };
    }

    // 2. å†™å…¥æ–‡ä»¶
    try {
      await fs.writeFile(filePath, content, 'utf-8');
      return {
        content: [
          {
            type: 'text',
            text: `âœ… File written successfully: ${filePath}`,
          },
        ],
      };
    } catch (error: any) {
      return {
        content: [
          {
            type: 'text',
            text: `âŒ Error writing file: ${error.message}`,
          },
        ],
        isError: true,
      };
    }
  }

  private async handleListDirectory(dirPath: string) {
    console.log(`[Server] list_directory: ${dirPath}`);

    // 1. éªŒè¯è·¯å¾„
    const validation = await this.validatePath(dirPath);
    if (!validation.valid) {
      return {
        content: [
          {
            type: 'text',
            text: `âŒ Error: ${validation.error}`,
          },
        ],
        isError: true,
      };
    }

    // 2. åˆ—å‡ºç›®å½•
    try {
      const entries = await fs.readdir(dirPath, { withFileTypes: true });

      const formatted = entries
        .map((entry) => {
          const type = entry.isDirectory() ? 'ğŸ“' : 'ğŸ“„';
          return `${type} ${entry.name}`;
        })
        .join('\n');

      return {
        content: [
          {
            type: 'text',
            text: `Directory: ${dirPath}\n\n${formatted}`,
          },
        ],
      };
    } catch (error: any) {
      return {
        content: [
          {
            type: 'text',
            text: `âŒ Error listing directory: ${error.message}`,
          },
        ],
        isError: true,
      };
    }
  }
}

// ========== ä½¿ç”¨ç¤ºä¾‹ ==========

async function main() {
  const server = new RootsAwareServer();
  console.log('[Server] Roots-aware server started');
}
```

### Python Client å®ç°

```python
from mcp import ClientSession
from mcp.types import Root
import os
from pathlib import Path
from typing import List, Optional, Dict
import asyncio

class RootsManager:
    def __init__(self, session: ClientSession):
        self.session = session
        self.allowed_roots: List[Root] = []

    async def handle_roots_list(self) -> Dict:
        """å¤„ç† roots/list è¯·æ±‚"""
        print("[Roots] Server requested roots list")
        return {
            "roots": [
                {"uri": root.uri, "name": root.name}
                for root in self.allowed_roots
            ]
        }

    # ========== Root ç®¡ç† ==========

    async def add_root(self, dir_path: str, name: Optional[str] = None) -> None:
        """æ·»åŠ ä¸€ä¸ª Root"""
        # 1. éªŒè¯è·¯å¾„
        path = Path(dir_path).resolve()
        if not path.exists():
            raise ValueError(f"Path does not exist: {dir_path}")
        if not path.is_dir():
            raise ValueError(f"Path is not a directory: {dir_path}")

        # 2. æ„å»º URI
        uri = f"file://{path}"

        # 3. æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if any(r.uri == uri for r in self.allowed_roots):
            print(f"[Roots] Root already exists: {uri}")
            return

        # 4. æ·»åŠ  Root
        root = Root(
            uri=uri,
            name=name or path.name
        )
        self.allowed_roots.append(root)

        print(f"[Roots] Added root: {uri}")

        # 5. é€šçŸ¥ Server
        await self.notify_roots_changed()

    async def remove_root(self, uri: str) -> None:
        """ç§»é™¤ä¸€ä¸ª Root"""
        original_length = len(self.allowed_roots)
        self.allowed_roots = [r for r in self.allowed_roots if r.uri != uri]

        if len(self.allowed_roots) < original_length:
            print(f"[Roots] Removed root: {uri}")
            await self.notify_roots_changed()
        else:
            print(f"[Roots] Root not found: {uri}")

    def get_roots(self) -> List[Root]:
        """è·å–æ‰€æœ‰ Roots"""
        return self.allowed_roots.copy()

    # ========== è·¯å¾„éªŒè¯ ==========

    def is_path_allowed(self, file_path: str) -> bool:
        """æ£€æŸ¥è·¯å¾„æ˜¯å¦åœ¨å…è®¸çš„ Roots å†…"""
        path = Path(file_path).resolve()
        file_uri = f"file://{path}"

        return any(
            file_uri.startswith(root.uri)
            for root in self.allowed_roots
        )

    def validate_path(self, file_path: str) -> Dict:
        """éªŒè¯è·¯å¾„ï¼Œè¿”å›è¯¦ç»†ç»“æœ"""
        # 1. è§„èŒƒåŒ–è·¯å¾„
        path = Path(file_path).resolve()
        file_uri = f"file://{path}"

        # 2. æ£€æŸ¥å±é™©æ¨¡å¼
        dangerous_patterns = ["../..", "~", "/etc/", "/sys/", "/proc/"]
        for pattern in dangerous_patterns:
            if pattern in str(path):
                return {
                    "valid": False,
                    "error": f"Path contains dangerous pattern: {pattern}"
                }

        # 3. æ£€æŸ¥æ˜¯å¦åœ¨å…è®¸çš„ Roots å†…
        matched_root = None
        for root in self.allowed_roots:
            if file_uri.startswith(root.uri):
                matched_root = root
                break

        if not matched_root:
            allowed_list = "\n".join(
                f"  - {r.name}: {r.uri}"
                for r in self.allowed_roots
            )
            return {
                "valid": False,
                "error": f"Path outside allowed roots.\n\nAllowed:\n{allowed_list}"
            }

        return {"valid": True}

    # ========== é€šçŸ¥ ==========

    async def notify_roots_changed(self) -> None:
        """å‘é€ Roots å˜åŒ–é€šçŸ¥"""
        try:
            await self.session.send_notification(
                "notifications/roots/list_changed"
            )
            print("[Roots] Sent list_changed notification")
        except Exception as e:
            print(f"[Roots] Failed to send notification: {e}")

# ========== ä½¿ç”¨ç¤ºä¾‹ ==========

async def example_usage():
    # å‡è®¾å·²ç»æœ‰ä¸€ä¸ª session
    # session = ClientSession(...)

    # roots_manager = RootsManager(session)

    # æ·»åŠ  Roots
    # await roots_manager.add_root("/home/user/projects/app-a", "Application A")
    # await roots_manager.add_root("/home/user/projects/app-b", "Application B")

    # éªŒè¯è·¯å¾„
    # validation = roots_manager.validate_path("/home/user/projects/app-a/main.py")
    # print(validation)  # {"valid": True}

    pass
```

---

## æœ€ä½³å®è·µ

### 1. è·¯å¾„éªŒè¯

```typescript
// âœ… å®Œå–„çš„è·¯å¾„éªŒè¯
class SecurePathValidator {
  private roots: Root[];

  validate(requestedPath: string): ValidationResult {
    // 1. è§„èŒƒåŒ–è·¯å¾„
    const normalized = path.resolve(requestedPath);

    // 2. æ£€æŸ¥è·¯å¾„å­˜åœ¨
    if (!fs.existsSync(normalized)) {
      return {
        valid: false,
        error: 'Path does not exist',
      };
    }

    // 3. æ£€æŸ¥å±é™©æ¨¡å¼
    const dangerous = ['..', '~', '/etc/', '/sys/', '/proc/', '/root/', 'C:\\Windows\\'];

    for (const pattern of dangerous) {
      if (normalized.includes(pattern)) {
        return {
          valid: false,
          error: `Dangerous pattern detected: ${pattern}`,
        };
      }
    }

    // 4. æ£€æŸ¥ç¬¦å·é“¾æ¥
    try {
      const stats = fs.lstatSync(normalized);
      if (stats.isSymbolicLink()) {
        const realPath = fs.realpathSync(normalized);
        // é€’å½’éªŒè¯çœŸå®è·¯å¾„
        return this.validate(realPath);
      }
    } catch (error) {
      return {
        valid: false,
        error: 'Failed to resolve symbolic link',
      };
    }

    // 5. æ£€æŸ¥ Roots
    const fileUri = `file://${normalized}`;
    const matchedRoot = this.roots.find((root) => fileUri.startsWith(root.uri));

    if (!matchedRoot) {
      return {
        valid: false,
        error: 'Path outside allowed roots',
      };
    }

    return { valid: true };
  }
}

// âŒ ä¸å®‰å…¨çš„éªŒè¯
function unsafeValidation(path: string, roots: Root[]): boolean {
  // å±é™©ï¼æ²¡æœ‰è§„èŒƒåŒ–è·¯å¾„
  return roots.some((r) => path.startsWith(r.uri));
}
```

### 2. ç¼“å­˜ç®¡ç†

```typescript
// âœ… æ™ºèƒ½ç¼“å­˜
class RootsCacheManager {
  private cache: { roots: Root[]; timestamp: number } | null = null;
  private readonly TTL = 30000; // 30 seconds

  async getRoots(): Promise<Root[]> {
    const now = Date.now();

    // æ£€æŸ¥ç¼“å­˜
    if (this.cache && now - this.cache.timestamp < this.TTL) {
      console.log('[Cache] Using cached roots');
      return this.cache.roots;
    }

    // è·å–æ–°æ•°æ®
    console.log('[Cache] Fetching fresh roots');
    const roots = await this.fetchRoots();

    // æ›´æ–°ç¼“å­˜
    this.cache = {
      roots,
      timestamp: now,
    };

    return roots;
  }

  invalidate(): void {
    console.log('[Cache] Invalidating cache');
    this.cache = null;
  }

  private async fetchRoots(): Promise<Root[]> {
    const response = await sendRequest({ method: 'roots/list' });
    return response.roots;
  }
}

// âŒ æ²¡æœ‰ç¼“å­˜
async function inefficientApproach() {
  // å±é™©ï¼æ¯æ¬¡éƒ½è¯·æ±‚
  for (let i = 0; i < 100; i++) {
    const roots = await sendRequest({ method: 'roots/list' });
    // ä½¿ç”¨ roots...
  }
}
```

### 3. é”™è¯¯å¤„ç†

```typescript
// âœ… æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯
class UserFriendlyErrors {
  formatAccessDeniedError(path: string, roots: Root[]): string {
    return `âŒ Access Denied

Requested path: ${path}

This path is outside the allowed directories.

Allowed directories:
${roots.map((r, i) => `  ${i + 1}. ${r.name || 'Unnamed'}\n     ${r.uri}`).join('\n')}

To access this path:
1. Open the directory in your editor/IDE
2. Or ask to add it to allowed roots`;
  }

  formatDangerousPathError(path: string, pattern: string): string {
    return `âŒ Security Error

Path contains dangerous pattern: ${pattern}

Requested: ${path}

This type of path is not allowed for security reasons.`;
  }
}

// âŒ æ¨¡ç³Šçš„é”™è¯¯
function badError() {
  throw new Error('Access denied'); // ç”¨æˆ·ä¸çŸ¥é“ä¸ºä»€ä¹ˆ
}
```

### 4. æ€§èƒ½ä¼˜åŒ–

```typescript
// âœ… æ‰¹é‡éªŒè¯
class BatchValidator {
  async validatePaths(paths: string[]): Promise<Map<string, boolean>> {
    const roots = await this.getRoots(); // åªè·å–ä¸€æ¬¡
    const results = new Map<string, boolean>();

    for (const path of paths) {
      const normalized = path.resolve(path);
      const fileUri = `file://${normalized}`;
      const valid = roots.some((root) => fileUri.startsWith(root.uri));
      results.set(path, valid);
    }

    return results;
  }
}

// âŒ æ¯æ¬¡éƒ½è·å– Roots
async function inefficientValidation(paths: string[]) {
  for (const path of paths) {
    const roots = await getRoots(); // é‡å¤è¯·æ±‚ï¼
    validate(path, roots);
  }
}
```

---

## å®‰å…¨æŒ‡å—

### 1. é˜²æ­¢è·¯å¾„éå†æ”»å‡»

```typescript
class PathTraversalProtection {
  private readonly BLOCKED_PATTERNS = [
    /\.\./g, // çˆ¶ç›®å½•å¼•ç”¨
    /~/, // Home ç›®å½•
    /^\/etc\//i, // Linux ç³»ç»Ÿç›®å½•
    /^\/sys\//i,
    /^\/proc\//i,
    /^\/root\//i,
    /^C:\\Windows\\/i, // Windows ç³»ç»Ÿç›®å½•
    /^C:\\Program Files\\/i,
  ];

  isPathSafe(userInput: string): boolean {
    // æ£€æŸ¥æ‰€æœ‰å±é™©æ¨¡å¼
    for (const pattern of this.BLOCKED_PATTERNS) {
      if (pattern.test(userInput)) {
        console.warn(`[Security] Blocked dangerous pattern: ${pattern}`);
        return false;
      }
    }

    return true;
  }

  sanitizePath(userInput: string): string {
    // ç§»é™¤å¤šä½™çš„æ–œæ 
    let sanitized = userInput.replace(/\/+/g, '/');

    // ç§»é™¤æœ«å°¾æ–œæ 
    sanitized = sanitized.replace(/\/$/, '');

    // è§„èŒƒåŒ–
    return path.resolve(sanitized);
  }
}
```

### 2. ç¬¦å·é“¾æ¥å¤„ç†

```typescript
class SymlinkHandler {
  async validateSymlink(symlinkPath: string, roots: Root[]): Promise<boolean> {
    try {
      const stats = await fs.lstat(symlinkPath);

      if (!stats.isSymbolicLink()) {
        return true; // ä¸æ˜¯ç¬¦å·é“¾æ¥ï¼Œç»§ç»­æ­£å¸¸éªŒè¯
      }

      // è§£æç¬¦å·é“¾æ¥çš„çœŸå®è·¯å¾„
      const realPath = await fs.realpath(symlinkPath);

      console.log(`[Symlink] ${symlinkPath} -> ${realPath}`);

      // éªŒè¯çœŸå®è·¯å¾„æ˜¯å¦åœ¨ Roots å†…
      const realUri = `file://${realPath}`;
      const allowed = roots.some((root) => realUri.startsWith(root.uri));

      if (!allowed) {
        console.warn(`[Security] Symlink points outside allowed roots: ${realPath}`);
      }

      return allowed;
    } catch (error) {
      console.error(`[Symlink] Error resolving: ${error}`);
      return false;
    }
  }
}
```

### 3. å®¡è®¡æ—¥å¿—

```typescript
class RootsAuditLogger {
  log(event: {
    action: string;
    path: string;
    allowed: boolean;
    root?: string;
    error?: string;
  }): void {
    const entry = {
      timestamp: new Date().toISOString(),
      type: 'roots_access',
      ...event,
    };

    console.log('[AUDIT]', JSON.stringify(entry));

    // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œåº”è¯¥å†™å…¥æŒä¹…åŒ–å­˜å‚¨
    // await db.auditLogs.insert(entry);
  }

  logAccess(path: string, allowed: boolean, matchedRoot?: Root): void {
    this.log({
      action: 'file_access',
      path,
      allowed,
      root: matchedRoot?.uri,
    });
  }

  logDenied(path: string, reason: string): void {
    this.log({
      action: 'access_denied',
      path,
      allowed: false,
      error: reason,
    });
  }
}
```

### 4. æƒé™æ£€æŸ¥

```typescript
class PermissionChecker {
  async checkFilePermissions(filePath: string): Promise<{
    readable: boolean;
    writable: boolean;
    executable: boolean;
  }> {
    try {
      // æ£€æŸ¥è¯»æƒé™
      await fs.access(filePath, fs.constants.R_OK);
      const readable = true;

      // æ£€æŸ¥å†™æƒé™
      let writable = false;
      try {
        await fs.access(filePath, fs.constants.W_OK);
        writable = true;
      } catch {}

      // æ£€æŸ¥æ‰§è¡Œæƒé™
      let executable = false;
      try {
        await fs.access(filePath, fs.constants.X_OK);
        executable = true;
      } catch {}

      return { readable, writable, executable };
    } catch (error) {
      return { readable: false, writable: false, executable: false };
    }
  }

  async enforceReadOnly(filePath: string): Promise<void> {
    // ç¡®ä¿æ–‡ä»¶æ˜¯åªè¯»çš„
    await fs.chmod(filePath, 0o444);
  }
}
```

---

## æ€»ç»“

### Roots çš„æ ¸å¿ƒä»·å€¼

1. **å®‰å…¨éš”ç¦»**: ä¿æŠ¤ç”¨æˆ·æ–‡ä»¶ç³»ç»Ÿä¸è¢«æœªæˆæƒè®¿é—®
2. **æ˜ç¡®è¾¹ç•Œ**: æ¸…æ™°å®šä¹‰æœåŠ¡å™¨çš„æ“ä½œèŒƒå›´
3. **ç”¨æˆ·æ§åˆ¶**: ç”¨æˆ·å®Œå…¨æ§åˆ¶å“ªäº›ç›®å½•å¯è¢«è®¿é—®
4. **åŠ¨æ€ç®¡ç†**: æ”¯æŒè¿è¡Œæ—¶æ·»åŠ /ç§»é™¤è®¿é—®æƒé™

### å…³é”®è¦ç‚¹

**âœ… å§‹ç»ˆåšåˆ°ï¼š**

- éªŒè¯æ¯ä¸ªæ–‡ä»¶è·¯å¾„
- è§„èŒƒåŒ–è·¯å¾„ï¼ˆä½¿ç”¨ `path.resolve`ï¼‰
- æ£€æŸ¥å±é™©æ¨¡å¼ï¼ˆ`..`, `/etc/`, ç­‰ï¼‰
- å¤„ç†ç¬¦å·é“¾æ¥
- ç¼“å­˜ Roots åˆ—è¡¨
- è®°å½•å®¡è®¡æ—¥å¿—

**âŒ ç»å¯¹é¿å…ï¼š**

- è·³è¿‡è·¯å¾„éªŒè¯
- å‡è®¾ Roots ä¸å˜
- ä½¿ç”¨å®½æ¾çš„éªŒè¯
- å¿½ç•¥ç¬¦å·é“¾æ¥
- æš´éœ²æ•æ„Ÿè·¯å¾„

### ä½¿ç”¨åœºæ™¯

| åœºæ™¯     | æè¿°               |
| -------- | ------------------ |
| IDE é›†æˆ | é™åˆ¶è®¿é—®å·¥ä½œåŒºç›®å½• |
| ç‰ˆæœ¬æ§åˆ¶ | åªè®¿é—® Git ä»“åº“    |
| æ–‡æ¡£å¤„ç† | é™åˆ¶åœ¨æ–‡æ¡£ç›®å½•     |
| æ„å»ºå·¥å…· | è®¿é—®é¡¹ç›®å’Œè¾“å‡ºç›®å½• |
| ä»£ç åˆ†æ | æ‰«æç‰¹å®šé¡¹ç›®ç›®å½•   |

### ä¸‹ä¸€æ­¥

- ğŸ”§ å®ç°è‡ªå·±çš„ Roots Manager
- ğŸ“š é˜…è¯» [MCP Roots è§„èŒƒ](https://modelcontextprotocol.io/specification/2025-06-18/client/roots)
- ğŸ¨ è®¾è®¡é€‚åˆä½ åº”ç”¨çš„ Roots ç­–ç•¥
- ğŸ”’ åŠ å¼ºå®‰å…¨é˜²æŠ¤æªæ–½
- ğŸš€ åœ¨ç”Ÿäº§ç¯å¢ƒä¸­æµ‹è¯•å’Œéƒ¨ç½²

---

## å‚è€ƒèµ„æº

- [MCP Roots è§„èŒƒ](https://modelcontextprotocol.io/specification/2025-06-18/client/roots)
- [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)
- [Path Traversal æ”»å‡»é˜²æŠ¤](https://owasp.org/www-community/attacks/Path_Traversal)
- [æ–‡ä»¶ç³»ç»Ÿå®‰å…¨æœ€ä½³å®è·µ](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html)

---

**License**: MIT  
**Last Updated**: 2025-06-18  
**Protocol Version**: 2025-06-18
